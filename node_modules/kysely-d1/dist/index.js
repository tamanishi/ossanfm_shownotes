"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _D1Dialect_config, _D1Driver_config, _D1Connection_config;
Object.defineProperty(exports, "__esModule", { value: true });
exports.D1Dialect = void 0;
const kysely_1 = require("kysely");
/**
 * D1 dialect that adds support for [Cloudflare D1][0] in [Kysely][1].
 * The constructor takes the instance of your D1 database that you bound in `wrangler.toml`.
 *
 * ```typescript
 * new D1Dialect({
 *   database: env.DB,
 * })
 * ```
 *
 * [0]: https://blog.cloudflare.com/introducing-d1/
 * [1]: https://github.com/koskimas/kysely
 */
class D1Dialect {
    constructor(config) {
        _D1Dialect_config.set(this, void 0);
        __classPrivateFieldSet(this, _D1Dialect_config, config, "f");
    }
    createAdapter() {
        return new kysely_1.SqliteAdapter();
    }
    createDriver() {
        return new D1Driver(__classPrivateFieldGet(this, _D1Dialect_config, "f"));
    }
    createQueryCompiler() {
        return new kysely_1.SqliteQueryCompiler();
    }
    createIntrospector(db) {
        return new kysely_1.SqliteIntrospector(db);
    }
}
exports.D1Dialect = D1Dialect;
_D1Dialect_config = new WeakMap();
class D1Driver {
    constructor(config) {
        _D1Driver_config.set(this, void 0);
        __classPrivateFieldSet(this, _D1Driver_config, config, "f");
    }
    async init() { }
    async acquireConnection() {
        return new D1Connection(__classPrivateFieldGet(this, _D1Driver_config, "f"));
    }
    async beginTransaction(conn) {
        return await conn.beginTransaction();
    }
    async commitTransaction(conn) {
        return await conn.commitTransaction();
    }
    async rollbackTransaction(conn) {
        return await conn.rollbackTransaction();
    }
    async releaseConnection(_conn) { }
    async destroy() { }
}
_D1Driver_config = new WeakMap();
class D1Connection {
    //   #transactionClient?: D1Connection
    constructor(config) {
        _D1Connection_config.set(this, void 0);
        __classPrivateFieldSet(this, _D1Connection_config, config, "f");
    }
    async executeQuery(compiledQuery) {
        // Transactions are not supported yet.
        // if (this.#transactionClient) return this.#transactionClient.executeQuery(compiledQuery)
        const results = await __classPrivateFieldGet(this, _D1Connection_config, "f").database
            .prepare(compiledQuery.sql)
            .bind(...compiledQuery.parameters)
            .all();
        if (results.error) {
            throw new Error(results.error);
        }
        const numAffectedRows = results.meta.changes > 0 ? BigInt(results.meta.changes) : undefined;
        return {
            insertId: results.meta.last_row_id === undefined || results.meta.last_row_id === null
                ? undefined
                : BigInt(results.meta.last_row_id),
            rows: results?.results || [],
            numAffectedRows,
            // @ts-ignore deprecated in kysely >= 0.23, keep for backward compatibility.
            numUpdatedOrDeletedRows: numAffectedRows,
        };
    }
    async beginTransaction() {
        // this.#transactionClient = this.#transactionClient ?? new PlanetScaleConnection(this.#config)
        // this.#transactionClient.#conn.execute('BEGIN')
        throw new Error('Transactions are not supported yet.');
    }
    async commitTransaction() {
        // if (!this.#transactionClient) throw new Error('No transaction to commit')
        // this.#transactionClient.#conn.execute('COMMIT')
        // this.#transactionClient = undefined
        throw new Error('Transactions are not supported yet.');
    }
    async rollbackTransaction() {
        // if (!this.#transactionClient) throw new Error('No transaction to rollback')
        // this.#transactionClient.#conn.execute('ROLLBACK')
        // this.#transactionClient = undefined
        throw new Error('Transactions are not supported yet.');
    }
    async *streamQuery(_compiledQuery, _chunkSize) {
        throw new Error('D1 Driver does not support streaming');
    }
}
_D1Connection_config = new WeakMap();
